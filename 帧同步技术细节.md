### 帧同步
```
1.	使用高效的网络协议 UDP
2.	使用定点数替代浮点数 (误差)
3.	冗余帧（前三帧）， 防止UDP丢包重连,UDP不会粘包
4.	使用protobuf 减小传输流量
5.	使用乐观锁帧技术, 防止卡帧（服务器定时同步，玩家卡顿或掉线，服务器发空帧）
6.	使用自己的物理引擎 (u3d的物理引擎基于浮点数)
7.	逻辑帧和渲染帧分离， 一般逻辑帧66ms(1秒15帧), 渲染帧可以小点(一秒30到60帧)， 保证平滑，客户端定时66ms发帧， 服务器定时66s收集发帧
8.	第一帧开始同步和锁帧(严格锁帧), 并下发随机种子
9.	客户端负责计算所有逻辑，服务器只同步动作等
10.	断线重连要追帧
向服务器请求第一帧到当前最新帧的所有数据，同时服务器从最新帧开始向客户端广播，客户端收到帧序列之后快进播放，直到赶上最新帧
11.	帧同步作弊比较容易
12.	可以使用预测回滚技术保证平滑， 断线重连不用从第一帧开始播， 使用预测回滚技术隔一段时间把当前的状态快照到客户端本地文件， 客户端断线重连时根据文件内容从断线时的帧状态开始追帧，这样可以快速追上

```

### 为什么使用UDP:
```
1.	传输效率高， 无干扰，用户可完全控制
2.	无连接，包头少， 只管发， 不管收， 所以快
3.	TCP 有流量控制， 窗口控制， 缓存控制， 有延迟， TCP 还要重发机制， 游戏逻辑不好控制
4.	UDP 要手动拆包， 需要带上帧序号
5.	帧同步要快
```

### 帧同步同步的是什么
```
1.	帧序号
2.	玩家的操作
移动位置， 方向，房间号，速度..
```

### 帧频率：
```
1.	客户端和服务器保持一致的帧频率，一般为66ms， 约1秒15帧
```

### 帧同步时序：
```
1．	Tcp协议 登录服务器
2.	Tcp 处理匹配请求
3.	Tcp 处理准备好请求和开局， 服务器创建好房间， 玩家进入房间等待
4.	当房间内玩家都准备好前， 服务器等待起始帧， 当都准备好后，客户端和服务器使用udp传输，服务器开始广播第1帧， 然后第2帧。。。
5.	相同的输入--->相同的输出， 所以服务器第一帧开始前要同步随机种子到所有客户端， 同时每一帧都要带上帧序号
```

### 帧同步流程

```
服务器
1, 服务器上每个比赛对象， 都有一个成员frameid, 保存了当前比赛下一帧要进入的id, frameid 初始化 为 1
2，我们在服务器上设定一个数据结构match_frames, 用来保存我们所有玩家的每帧操作， 这个结构用来支持录像回放，断线重连，不同步的情况， 有无作弊(调试), UDP丢包和时序问题，丢包时要补发给客户端
3，next_frame_opt, 每帧服务器采集来的客户端的操作，都存放在这里
   frameid = self.frameid(有操作玩家的操作)
4， 服务器上启动一个定时器，每隔66ms触发一次on_logic_frame
5, 保存我们当前的操作到match_frames
6, 遍历每个玩家，每个玩家发送我们的帧操作
7，服务器进入下一阵， self.frameid = self.frameid + 1
8，服务器进入采集下一阵模式，清空上一阵的操作
   self.next_frame_opt = {frameid = self.frameid, opts = {}}
9, 发送服务器认为这个玩家还没有同步的帧， 每个玩家对象，sync_frameid = 98, 记录当前这个客户端， 已经同步到了多少帧， sync_frameid + 1,....最新的帧100， 发第100帧的时候要补发第99帧 [99,100]
  因为UDP 有丢包和时序问题，补发我们的帧
10，采用UDP 将我们第100帧的数据包发送出去 ([99,100])

客户端
11. 客户端通过网络收到帧同步的数据包以后， on_logic_update
12. 每个客户端， 都会有一个sync_frameid, 用于记录一下当前客户端真正已经同步到哪个帧
13. 如果收到的帧id 小于 客户端已经同步过的帧id, 直接丢弃这个帧
  1. 为什么会出现这个情况? 99帧， 处理完了100帧， 因为 UDP 可能先发后到， 后发先到 的时序问题
  2. 为什么我们没有收到99帧， 就开始处理100帧，这个还能同步吗？ 99 帧没有处理， 服务器发100帧的时候会补发99帧
14. 如果上一阵的操作不会null, 那么这个时候，我们处理下一帧之前一定要先同步上一帧的结果
   在播放动画的帧与帧之间，我们会出现时间的差异，会导致位置等不同步， logic_pos: 66ms --》 迭代计算出新的位置和结果，统一都以66ms迭代
   帧同步： 每帧都同步，处理下一帧之前，每帧都要同步，同样的输入-》同样的输出
15，跳帧： 快速的同步完所有过时的帧，直到最新的帧
16， 控制我们的客户端，来根据操作，播放动画，更新我的逻辑向前推进
17， 采集我们的操作，上报给服务器你认为的的下一帧 next_frame.frameid = this.sync_frameid + 1

服务器：
18. 收到玩家的操作，更新服务器上认为玩家已经处理的帧id
19. 如果收到玩家操作的帧id next_frame_opts.frameid 等于马上要触发的帧id, 则正常进行， 如果收到过时的操作， 丢弃
   直接丢弃不影响玩家的手感，
20，保存玩家的操作， 等待下一帧的触发
```
